# -*- coding: utf-8 -*-
"""GS_Dynamic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QEsNks2CJBSQFsUC9Hb7KUVJjZrt-e2h
"""

import pandas as pd

# Definição das áreas marinhas com dados fictícios
areas_marinhas = [
    {'id': 1, 'biodiversidade': 8, 'vulnerabilidade': 7, 'conectividade': 5, 'area': 100},
    {'id': 2, 'biodiversidade': 6, 'vulnerabilidade': 5, 'conectividade': 6, 'area': 150},
    {'id': 3, 'biodiversidade': 7, 'vulnerabilidade': 6, 'conectividade': 6, 'area': 120},
    {'id': 4, 'biodiversidade': 5, 'vulnerabilidade': 8, 'conectividade': 7, 'area': 180},
    {'id': 5, 'biodiversidade': 9, 'vulnerabilidade': 6, 'conectividade': 4, 'area': 130}
]

# Função para calcular o valor de uma área marinha com base nos pesos
def calcular_valor_area(area, pesos):
    valor = area['biodiversidade'] * pesos['biodiversidade'] + \
            area['vulnerabilidade'] * pesos['vulnerabilidade'] + \
            area['conectividade'] * pesos['conectividade']
    return valor

# Função para calcular o custo de cada área marinha
def calcular_custo_area(area, pesos):
    return 100 * calcular_valor_area(area, pesos)

# Solicitar os custos para cada área marinha com base no valor
for i, area in enumerate(areas_marinhas):
    custo_area = calcular_custo_area(area, {'biodiversidade': 0.4, 'vulnerabilidade': 0.3, 'conectividade': 0.3})
    areas_marinhas[i]['custo'] = custo_area

# Criar um DataFrame com os dados das áreas marinhas
df_areas_marinhas = pd.DataFrame(areas_marinhas)

# Adicionar o custo por metro quadrado ao DataFrame
df_areas_marinhas['custo_por_metro_quadrado'] = df_areas_marinhas['custo'] / df_areas_marinhas['area']

# Solicitar o orçamento ao usuário com tratamento de erro
while True:
    try:
        orcamento_inicial = float(input("Digite o orçamento disponível: "))
        break
    except ValueError:
        print("Por favor, insira um valor numérico válido.")

# Ordenar as áreas marinhas pelo custo por metro quadrado em ordem crescente
df_areas_marinhas = df_areas_marinhas.sort_values(by='custo_por_metro_quadrado')

# Selecionar as áreas com menor custo por metro quadrado que não excedam o orçamento
area_acumulada = 0
orcamento_restante = orcamento_inicial
areas_selecionadas = []
for index, row in df_areas_marinhas.iterrows():
    if row['custo'] <= orcamento_restante:
        areas_selecionadas.append(row)
        orcamento_restante -= row['custo']

# Função para exibir o orçamento restante
def exibir_orcamento_restante(orcamento_inicial, orcamento_restante):
    print(f"\nOrçamento inicial: {orcamento_inicial}")
    print(f"Orçamento restante: {orcamento_restante}")

# Verificar se alguma área foi selecionada
if not areas_selecionadas:
    print("Esse orçamento é insuficiente para as áreas marinhas.")
else:
    # Ordenar o DataFrame original pelo custo em ordem crescente
    df_areas_marinhas_ordenado_por_preco = df_areas_marinhas.sort_values(by='custo')

    # Exibir as áreas marinhas selecionadas sem a coluna custo_por_metro_quadrado
    print("\nÁreas marinhas selecionadas:")
    print(pd.DataFrame(areas_selecionadas).drop(columns=['custo_por_metro_quadrado']))

    # Exibir o orçamento inicial e restante
    exibir_orcamento_restante(orcamento_inicial, orcamento_restante)

    # Exibir as áreas marinhas ordenadas por preço
    print("\nÁreas marinhas ordenadas por preço:")
    print(df_areas_marinhas_ordenado_por_preco[['id', 'area', 'custo']])

    # Exibir as áreas marinhas ordenadas por custo por metro quadrado
    print("\nÁreas marinhas ordenadas por custo por metro quadrado:")
    print(df_areas_marinhas[['id', 'area', 'custo_por_metro_quadrado']])